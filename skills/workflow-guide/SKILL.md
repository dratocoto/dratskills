---
name: workflow-guide
description: >
  This skill should be used when the user asks about "how the AI team works",
  "workflow", "agent roles", "handoff process", "task management",
  "project setup", "start working on a feature", or needs to understand
  the multi-agent development process and human-AI collaboration model.
version: 0.5.0
---

# AI Dev Team Workflow

A multi-agent development workflow where AI agents function as a specialized team,
and the human serves dual roles: **End User** (giving requirements) and **Tech Lead** (overseeing quality).

## Team Structure (9 Agents)

```
Human (End User + Tech Lead)
        ↕
   PM Agent ← Coordinator + Discussion Moderator
        ↓
  ┌───┬─┼────────┬───────┬────┬─────┐
  ↓   ↓ ↓        ↓       ↓    ↓     ↓
 BA Arch BackDev FrontDev Rev Test   QA
          ↕   ↕    ↕       ↕        ↕
        (discussions between agents)

  Researcher ← On-demand (any agent can request via PM)
```

| Agent | Role | Reads | Writes |
|-------|------|-------|--------|
| **PM** | Coordinate, delegate, moderate discussions, manage parallel features | STATE.md, stack.config.yaml, handoffs, discussions | STATE.md, task cards, handoffs |
| **BA** | Clarify ideas (QA questions), write requirements | STATE.md, stack.config.yaml, codebase structure | features/FEAT-XXX/requirement.md, discussions/ |
| **Architect** | Design system, define interfaces, create specs | requirement.md, stack.config.yaml, codebase structure | features/FEAT-XXX/design.md, discussions/ |
| **Backend Dev** | Implement backend code following specs and conventions | task card, stack.config.yaml, CONVENTIONS.md, reviews/ | src/ backend code, discussions/ |
| **Frontend Dev** | Implement frontend code following specs and conventions | task card, stack.config.yaml, CONVENTIONS.md, reviews/ | src/ frontend code, discussions/ |
| **Reviewer** | Peer code review (quality, patterns, bugs) | task card, stack.config.yaml, CONVENTIONS.md, src/ | features/FEAT-XXX/reviews/, discussions/ |
| **Tester** | Write tests, verify coverage | design.md, stack.config.yaml, src/ code, CONVENTIONS.md | tests/, discussions/ |
| **QA** | Acceptance testing, security, production readiness | requirement.md, design.md, stack.config.yaml, src/, tests/ | features/FEAT-XXX/reviews/, discussions/ |
| **Researcher** | Technical research, best practices, comparisons | stack.config.yaml, codebase structure, web sources | features/FEAT-XXX/discussions/RESEARCH-XXX.md |

## Dynamic Skill System

Agent skill configuration uses a two-level config:

1. **`team.config.yaml`** (plugin-level, static) — defines which skill _categories_ each agent needs
2. **`.ai-workspace/stack.config.yaml`** (per-project, generated by `/start-project`) — resolves categories to actual skill folder names

```
team.config.yaml defines:
  backend-dev-agent.skills: [backend-patterns, language, conventions]

stack.config.yaml resolves:
  backend-patterns → "fastapi-patterns"
  frontend-guide   → "nextjs16-guide" (or "_none_")
  language         → "python312"
  conventions      → "conventions"

Agent reads team.config.yaml → gets categories → reads stack.config.yaml → resolves skill name
  → loads ${CLAUDE_PLUGIN_ROOT}/skills/{skill_name}/SKILL.md
```

This means the same agents work with any tech stack — just change `stack.config.yaml`.

## Shared Workspace: `.ai-workspace/`

All agents communicate through files in `.ai-workspace/`. Each feature gets its own isolated directory for parallel execution:

```
.ai-workspace/
├── STATE.md                 ← Global dashboard: ALL features, conflict map
├── stack.config.yaml        ← Tech stack config: resolves skill categories to skills
├── CONVENTIONS.md           ← Shared coding rules (all features follow)
├── CHECKLIST.md             ← Pre-commit quality checklist
├── features/                ← Feature-scoped workspaces
│   ├── FEAT-001/            ← Auth feature (own pipeline)
│   │   ├── requirement.md   ← BA's requirement doc
│   │   ├── design.md        ← Architect's design spec
│   │   ├── tasks/           ← Implementation task cards (labeled backend/frontend)
│   │   │   ├── TASK-001.md
│   │   │   └── TASK-002.md
│   │   ├── reviews/         ← Peer reviews + QA report
│   │   │   ├── TASK-001-review.md
│   │   │   └── qa-report.md
│   │   ├── discussions/     ← Within-feature discussions + research reports
│   │   │   ├── DISC-001.md
│   │   │   └── RESEARCH-001.md
│   │   └── handoffs/        ← Phase transition handoffs
│   │       └── HANDOFF-latest.md
│   └── FEAT-002/            ← Catalog feature (parallel pipeline)
│       ├── requirement.md
│       ├── design.md
│       ├── tasks/
│       ├── reviews/
│       ├── discussions/
│       └── handoffs/
├── discussions/             ← Cross-feature discussions
│   └── DISC-CROSS-001.md
└── decisions/               ← Shared Architecture Decision Records
    └── ADR-001.md
```

### Parallel Feature Rules

1. **Agent isolation**: When working on FEAT-001, ALL file refs point to `features/FEAT-001/`
2. **No cross-reading**: Backend Dev on FEAT-001 does NOT read FEAT-002 files
3. **Shared conventions**: CONVENTIONS.md and stack.config.yaml are shared — read from root
4. **Conflict detection**: Before IMPL phase, PM checks File Conflict Map in STATE.md
5. **Cross-feature discussions**: If features touch same files → open in root `discussions/`

## The 7-Phase Workflow

### Phase 0: CLARIFY → BA Agent (Idea Clarification)
1. Human describes the feature in natural language (can be vague)
2. PM delegates to **BA Agent**
3. BA analyzes what is CLEAR vs VAGUE vs MISSING
4. BA asks **3-7 targeted QA questions** to clarify the idea
5. Human answers → BA has clear understanding

### Phase 1: REQUIREMENT → BA Agent
1. BA creates structured requirement doc from the clarified idea
2. BA writes `features/FEAT-XXX/requirement.md` using the template
3. Requirement includes a **Clarification Log** — full Q&A for traceability
4. BA hands back to PM → PM presents to human for **approval** → CHECKPOINT

### Phase 2: DESIGN → Architect Agent
1. PM triggers Architect scoped to `features/FEAT-XXX/`
2. Architect reads `features/FEAT-XXX/requirement.md` + scans existing codebase
3. Architect loads skills via team.config.yaml + stack.config.yaml for framework-specific patterns
4. Architect produces `features/FEAT-XXX/design.md` with:
   - Component diagram, data models, API contracts
   - File list with responsibilities (used for File Conflict Map)
   - Breaking into implementation tasks **labeled `backend` or `frontend`**
5. PM checks File Conflict Map → if overlap with other features, opens cross-feature discussion
6. PM presents design to human → **CHECKPOINT**

### Phase 3: IMPLEMENT → Backend Dev / Frontend Dev (task by task)
1. PM creates task cards in `features/FEAT-XXX/tasks/`, each labeled `backend`, `frontend`, or `full-stack`
2. PM routes each task to the appropriate dev agent:
   - `backend` → **Backend Dev**
   - `frontend` → **Frontend Dev**
   - `full-stack` → **Backend Dev** first, then **Frontend Dev**
3. Dev agent receives ONLY:
   - The task card (what to do, which files to read/write)
   - Reference to relevant design section
   - Skills loaded via team.config.yaml + stack.config.yaml
4. Dev agent implements and self-validates against checklist
5. After each task → Reviewer does peer review

### Phase 4: REVIEW → Reviewer Agent (per task)
1. Reviewer reads task card + code output
2. Loads relevant skills via config (backend or frontend depending on task label)
3. Checks patterns, bugs, quality, conventions
4. Writes `features/FEAT-XXX/reviews/TASK-XXX-review.md` with verdict
5. If CHANGES_REQUESTED → Dev fixes → Reviewer re-reviews (max 3 rounds)
6. If APPROVED → proceed to next task or testing

### Phase 5: TEST → Tester Agent
1. PM triggers Tester scoped to `features/FEAT-XXX/`
2. Tester reads design (expected behavior) + code (actual implementation)
3. Loads test framework via stack.config.yaml (pytest for Python, vitest for TypeScript)
4. Generates unit tests, integration tests per testing conventions
5. Runs tests, reports coverage
6. If tests fail → loop back to appropriate Dev with failure details

### Phase 6: QA → QA Agent → Human
1. QA validates feature against **acceptance criteria** from requirement
2. Loads skills via config for stack-specific checks
3. Runs security + production readiness checks
4. Produces `features/FEAT-XXX/reviews/qa-report.md`
5. PM presents QA report to human → **FINAL CHECKPOINT**
6. Human approves → Done, or requests changes → loop back

### On-Demand: RESEARCH → Researcher Agent
- Any agent can request research through PM at any point
- Researcher investigates technical questions, best practices, library comparisons
- Writes `RESEARCH-XXX.md` report in the feature's discussions directory
- PM routes the findings back to the requesting agent

## Agent Communication

Agents communicate through **3 channels** (see `references/communication-protocol.md`):

### 1. Handoffs (pipeline flow)
```
BA → PM → Architect → PM → Backend Dev/Frontend Dev → Reviewer → PM → Tester → PM → QA → PM → Human
```

### 2. Discussions (any agent ↔ any agent)
Within-feature discussions → `features/FEAT-XXX/discussions/DISC-XXX.md`
Cross-feature discussions → root `discussions/DISC-CROSS-XXX.md`

Examples:
- Backend Dev asks Architect about design feasibility (within-feature)
- Frontend Dev asks Backend Dev about API contract (within-feature)
- Tester asks BA to clarify acceptance criteria (within-feature)
- Reviewer opens debate with Backend Dev about approach (within-feature)
- QA raises cross-cutting concern with everyone (cross-feature)
- PM detects file conflict between FEAT-001 and FEAT-002 (cross-feature)
- Any agent requests Researcher to investigate a technical question (within-feature)

PM moderates: routes, facilitates, escalates (max 3 rounds → human decides).

### 3. Review Comments (feedback loops)
- Reviewer → Backend Dev or Frontend Dev: peer review with fix/discuss/accept cycle
- QA → any agent: final quality findings

## Context Management Rules

**Problem**: AI has limited context. Loading everything = poor quality.

**Solution**: Each agent loads ONLY what it needs.

| Agent | Max Files to Load | What to Load |
|-------|-------------------|-------------|
| PM | 4 | STATE.md, stack.config.yaml, current handoff, discussions (if OPEN) |
| BA | 5 | STATE.md, stack.config.yaml, codebase structure (ls/tree), existing requirement (if revising) |
| Architect | 5 | requirement doc, stack.config.yaml, existing structure (ls/tree), key interfaces |
| Backend Dev | 5 | task card, resolved skills, CONVENTIONS.md, files to modify |
| Frontend Dev | 5 | task card, resolved skills, CONVENTIONS.md, files to modify |
| Reviewer | 5 | task card, resolved skills, CONVENTIONS.md, source files being reviewed |
| Tester | 5 | spec section, resolved skills, source files to test |
| QA | 7 | requirement doc, spec, resolved skills, CONVENTIONS.md, source files, test files |
| Researcher | 7 | stack.config.yaml, codebase structure, relevant source files, web sources |

**Rules for keeping context small**:
1. CONVENTIONS.md uses checklist format, not prose (< 200 lines)
2. Each task card contains exactly what the agent needs + file refs
3. Specs use tables and bullet points, not paragraphs
4. Large features are broken into tasks of ≤ 3 files each
5. Handoff files provide explicit "what to read" instructions
6. Discussions are concise: problem + options + recommendation

## Handoff Protocol

When Agent A finishes and Agent B takes over (within a feature):

```
Agent A completes work (scoped to FEAT-XXX)
    → writes output files in features/FEAT-XXX/
    → writes features/FEAT-XXX/handoffs/HANDOFF-latest.md

PM reads HANDOFF-latest.md
    → updates STATE.md (global dashboard)
    → checks for open discussions (feature + cross-feature)
    → determines next step
    → triggers Agent B scoped to features/FEAT-XXX/
```

See `references/handoff-protocol.md` for the full handoff schema.

## Human Intervention Points

The human can intervene at any time, but MUST approve at these checkpoints:

| Checkpoint | After Phase | Human Reviews | Can Reject? |
|-----------|------------|---------------|-------------|
| CLARIFY | Clarification | BA asks QA questions, human answers | N/A — conversational |
| REQ-APPROVE | Requirement | Is this what I want? | Yes → rewrite |
| DESIGN-APPROVE | Design | Is the architecture right? | Yes → redesign |
| REVIEW-SPOT-CHECK | Every 3 tasks | Reviewer's comments + code | Yes → fix specific issues |
| QA-APPROVE | QA Report | Is it production-ready? | Yes → loop back |

## Additional Resources

- **`references/workflow-phases.md`** — detailed phase descriptions with examples
- **`references/handoff-protocol.md`** — handoff schema and templates
- **`references/communication-protocol.md`** — discussion threads, review comments, agent interaction
- **`references/context-management.md`** — strategies for managing AI context limits
- **`templates/`** — file templates for requirements, specs, tasks, reviews, discussions
